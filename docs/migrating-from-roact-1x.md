## Minimum Requirements

When upgrading to Roact 17+, uses of certain legacy patterns and features need to be cleaned up entirely to maintain correct behavior. Once these conditions are met, your legacy Roact code should work as expected in Roact 17.

### No Reserved Props

In Roact 17, components cannot rely on any reserved prop keywords:

* "ref" - reserved by Roact to assign refs, equivalent to legacy Roact's `Roact.Ref`
* "key" - reserved by Roact to assign stable keys to children
* "children" - reserved by Roact as a special prop representing the children passed down to the component

If your component is using "ref" or "key" as the name of one of its props, it will no longer be populated with a value in Roact 17+. If it's using "children" as the name of one of its props, it will be populated with the table of child elements instead of any passed-in value.

### No Legacy Context

Legacy Roact implemented a `_context` field on all component instances as an alternative implementation for the Context feature. This is deprecated in legacy Roact and is not supported in Roact 17+.

Instead, use the [Provider and Consumer pattern via `createContext`](https://roblox.github.io/roact/advanced/context/). The `createContext` API is available in legacy Roact 1.3.0 (or newer) and is fully supported in Roact 17.

### Explicit Ref Forwarding

Legacy Roact uses `Roact.Ref` as a special prop key to support the refs feature. Assigning the `[Roact.Ref]` property to a callback ref or ref object allows Roact to assign its value. However, Roact only interacts with the `Roact.Ref` property if the component receiving the props is a host component.

Some class component definitions rely on this behavior by accepting and reassigning the `[Roact.Ref]` prop themselves, knowing that Roact won't capture it. This pattern is called "ref forwarding", and is supported explicitly with the `React.forwardRef` API.

In Roact 17+, `Roact.Ref` is aliased to the string "ref", and refs that point to class components are now supported. Components that were forwarding refs using the above method will now fail to forward their provided refs. To fix this, use the [`forwardRef` function](https://roblox.github.io/roact/advanced/bindings-and-refs/#ref-forwarding).

The `forwardRef` API is available in legacy Roact 1.4.0 (or newer) and is fully supported in Roact 17.

### Prefer getDerivedStateFromProps
Legacy Roact allows class components to implement both `willUpdate` and `getDerivedStateFromProps` lifecycle methods.

React JS, however, does not support both methods when implemented on the same component. When `getDerivedStateFromProps` is defined, it _replaces_ `componentWillUpdate` entirely. **Roact 17 inherits this restriction.**

In order to migrate existing components, make sure to use _either_ `willUpdate` or `getDerivedStateFromProps`, but not both. Whenever possible, use `getDerivedStateFromProps` to resolve interactions between state and props. As in React JS, `componentWillUpdate` is a legacy lifecycle method and should be avoided as [it can exacerbate problems with asynchronous rendering.

Refer to the React JS guidance on [migrating away from legacy lifecycle methods](https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html).

## Adding a Roact 17 Dependency
Roact 17 is available as a collection of packages hosted in the https://github.com/roblox/roact-alignment repository. Internal Roblox processes use a package manager called [Rotriever](https://github.com/roblox/rotriever) to resolve and manage dependencies.

!!! info
	Roact 17 is a "package workspace", meaning that it consists of multiple packages living in the same project. We recommend using Rotriever version [0.5.0-rc.4](https://github.com/Roblox/rotriever/releases/tag/v0.5.0-rc.4) or newer to make sure it has workspace support.

	Refer to [Rotriever's documentation](https://roblox.github.io/rotriever/installation/) for more information on how to install or upgrade your version.

### New Projects

1. Make sure you're using rotriever version `0.5.0-rc.4` or newer. You can check this by running `rotrieve -V`.
2. Add the following to your `rotriever.toml` manifest file:
	```toml
	[dependencies]
	React = "github.com/roblox/roact-alignment@17.0.1-rc.8"
	ReactRoblox = "github.com/roblox/roact-alignment@17.0.1-rc.8"
	```
3. Run `rotrieve install` to install all dependencies
4. `React.lua` and `ReactRoblox.lua` will be added to the `Packages` folder generated by rotriever in your project. Make sure this folder is included in your project when testing with `roblox-cli` or Roblox Studio.

### Replacing Legacy Roact
The easiest way to adopt Roact 17 in an existing Roact project is to change your existing dependency on legacy Roact.

Make the following changes to your `rotriever.toml` manifest file:
```diff
[dependencies]
- Roact = "github.com/roblox/roact@1.4"
+ Roact = { target = "github.com/roblox/roact-alignment", version = "17.0.1-rc.8", package = "RoactCompat" }
```

This creates a dependency on the `RoactCompat` package, which provides [a compatibility layer](api-reference/roact-compat.md) for migrating from legacy APIs. Since it's still named `Roact` in the above snippet, it will be aliased to `Roact` in your code and will not require any changes to your source code.

However, the `RoactCompat` API only covers enough to provide backwards compatibility. To access new features like hooks or suspense, add dependencies on `React` and `ReactRoblox` too:
```toml
[dependencies]
Roact = { target = "github.com/roblox/roact-alignment", version = "17.0.1-rc.8", package = "RoactCompat" }
React = "github.com/roblox/roact-alignment@17.0.1-rc.8"
ReactRoblox = "github.com/roblox/roact-alignment@17.0.1-rc.8"
```

!!! info
	Since we're not aliasing the `React` and `ReactRoblox` packages, we can define our dependencies using the shorthand format. Read up on [specifying Rotriever dependencies](https://roblox.github.io/rotriever/guide/specifying-dependencies/) for more information.

#### Patching Other Dependencies
One thing you may need to account for is any other dependencies that use Roact. If you have a dependency that has its own dependency on legacy Roact, you may need to use rotriever's `patch` feature to swap out the legacy version.

You may encounter this if you have existing dependencies on any of the following:

* [InfiniteScroller](https://github.com/Roblox/infinite-scroller) (supports Roact 17 in 0.8.0 and newer)
* [RoactFitComponents](https://github.com/roblox/roact-fit-components) (supports Roact 17 in 2.0.0 and newer)
* [RoactRodux](https://github.com/Roblox/roact-rodux) (supports Roact 17 in 0.4.1 and newer)
* [UIBlox](https://github.com/Roblox/uiblox) (supports Roact 17 on the latest master)
* Numerous other projects that depend on legacy Roact

To resolve this, you can patch over any dependencies on legacy Roact and align them with your newly-added version. Add this additional section to your `rotriever.toml` manifest file:
```toml
[config.patch."github.com/roblox/roact"]
Roact = { target = "github.com/roblox/roact-alignment", version = "17.0.1-rc.8", package = "RoactCompat" }
```

To learn more about patching dependencies, check out [the Rotriever documentation](https://roblox.github.io/rotriever/guide/specifying-dependencies/#patching-dependencies).

!!! caution
	When you're patching over Roact, make sure your other dependencies are compatible with Roact 17. They may need recent changes to comply with the [Roact 17 requirements](#minimum-requirements) specified above.

### Testing with Both
In some cases, you may not yet be ready to adopt Roact 17, but you want to start adopting it in tests or storybooks.

One reasonable way to accomplish this is to depend on _both_ projects, but to conditionally swap in Roact 17 at runtime. To do this, make sure your `rotriever.toml` manifest file contains the following:
```toml
[dependencies]
Roact = "github.com/roblox/roact@1.4"

[dev_dependencies]
RoactCompat = "github.com/roblox/roact-alignment@17.0.1-rc.8"
```

This declares a dependency on legacy Roact as well as a [dev dependency](https://roblox.github.io/rotriever/guide/specifying-dependencies/#development-dependencies) on Roact 17.

In your test runner script or other equivalent entry point, check the value of a global (or flag, or any other preferred configuration method), and overwrite the `Roact` API with that of `RoactCompat` when enabled. It may look something like this:

```lua
if _G.__NEW_ROACT__ then
	local Roact = require(Packages.Roact)
	local RoactCompat = require(Packages.Dev.RoactCompat)

	-- Overwrite the contents of the `Roact` package with that of the
	-- RoactCompat package
	for api, _ in pairs(Roact) do
		Roact[api] = RoactCompat[api]
	end
end

-- Proceed with test setup...
```

To see this logic in context, you can find a comprehensive example [in the UIBlox library](https://github.com/Roblox/uiblox/blob/master/bin/run-tests.server.lua).

## Adopting New Rendering Behavior
*Under construction ðŸ”¨*

In addition to newly added APIs, Roact 17 also includes changes to the underlying rendering behavior. Roact 17 enables opt-in use of [Concurrent Mode](https://reactjs.org/docs/concurrent-mode-intro.html), which allows Roact to split work across multiple frames and preserve high framerate and interactivity.

**Roact 17 will use Concurrent Mode by default in its `mount` compatibility layer.**

### ReactRoblox.createRoot
In legacy Roact, the [`Roact.mount`](https://roblox.github.io/roact/api-reference/#roactmount) function is used to render a component tree. In React JS 17 and older, the primary entry-point for rendering a component tree is [`ReactDOM.render`](https://reactjs.org/docs/react-dom.html#render), while the experimental `ReactDOM.createRoot` API is used to adopt Concurrent Mode.

Roact 17 skips introducing the top-level `render` function, and instead includes:

* The `createRoot`, `createBlockingRoot`, and `createLegacyRoot` APIs from React JS 17
* A [compatibility layer](api-reference/roact-compat.md#roactcompatmount) that exports a `mount` function aligned with legacy Roact's API

In new code, use [`ReactRoblox.createRoot`](https://reactjs.org/docs/concurrent-mode-reference.html#createroot). In code that's not yet ready for Concurrent Mode, use [`ReactRoblox.createBlockingRoot` or `ReactRoblox.createLegacyRoot`](https://reactjs.org/docs/concurrent-mode-reference.html#createblockingroot).

### ReactRoblox.act
When Concurrent Mode is enabled, Roact will attempt to schedule work evenly across frames to keep the application running smoothly, even when UI rendering is in progress.

However, this means that tests relying on synchronous rendering behavior will no longer function correctly. To fix this, use the [`ReactRoblox.act`](api-reference/react-roblox.md#reactrobloxact) function to play scheduler logic forward (also re-exported as [`RoactCompat.act`](api-reference/roact-compat.md#roactcompatact)).

!!! info
	Note that in order to enable `act` functionality, you'll need to tell Roact to use the mocked version of its internal scheduler. To do this, set the [`__ROACT_17_MOCK_SCHEDULER__`](configuration.md#__roact_17_mock_scheduler__) global to true in your testing configuration.

When writing tests for Concurrent Mode, there are a few things you should keep in mind:

* `ReactRoblox.act` will run the provided function, and then play forward the scheduler afterwards. To make sure your Roact logic runs, the following types of logic should be wrapped in `act`:
	* Rendering an initial tree with the `render` method of a React root or the `RoactCompat.mount` compatibility function (if the [`__ROACT_17_INLINE_ACT__`](configuration.md#__roact_17_inline_act__) global is set to true, this will happen **automatically** for `mount`, `update`, and `unmount`)
	* Rendering updates with the `render` method of a React root
	* Unmounting a tree by passing `nil` to the `render` method of a React root
	* Calling `task.wait` to allow engine callbacks to fire
	* Triggering any behavior that causes a component to call `setState`, including firing signals that your component has subscribed to
	* Processing user inputs generated by Rhodium
* Some engine events simulated through Rhodium's virtual input may not resolve immediately, and may need to be followed by `task.wait` before they've queued up any work for `act` to play forward
* In tests that frequently perform input events, consider creating helpers that wrap common behavior in `act`. For example:
```lua
local function actSendText(instance, text, timeout)
	ReactRoblox.act(function()
		instance:sendText(text)
		task.wait(timeout)
	end)
end
```

Refer to documentation on [React JS' `act` function](https://reactjs.org/docs/test-utils.html#act) for more details and examples.

## Updating Conventions and APIs
### When to use RoactCompat vs. React/ReactRoblox
* Almost all legacy Roact code can be patched to Roact 17 using the RoactCompat library. However, while RoactCompat is backwards compatible with with Legacy Roact, it does not export new Roact 17 features like hooks.
* When writing code exclusively for Roact 17, you should access the primary APIs of Roact 17 through the `React` and `ReactRoblox` APIs, instead of through `RoactCompat`
* `React` exposes all of the Legacy Roact APIs (`createElement`, `createContext`, `Fragment`, `Children`, etc.), and some new ones (`useState`, `useRef`, `memo`, `cloneElement`, etc.).
* `ReactRoblox` exposes APIs to handle `Change` and `Event` callbacks for React components, replacing RoactCompat's `Roact.Change.<property>` and `Roact.Event.<event>` API.
* Try to avoid using `RoactCompat` and `React`/`ReactRoblox` in the same file. If you are adding new Roact features to code that uses `RoactCompat` syntax, you should take the following steps:
    1. Replace the `Roact` import with the `React` import.
	2. Swap all uses of `Roact` with `React`.
	3. If there are uses of `Roact.Change` or `Roact.Event`, import `ReactRoblox` and replace the uses with `ReactRoblox.Change` and `ReactRoblox.Event`, respectively.
	4. Begin adopting new features as needed.


#### RoactCompat Code:
```lua
local Roact = require(Packages.Roact)

function GenericComponent(props)
    return Roact.createElement("TextButton", {
        BackgroundColor3 = props.color,
	[Roact.Event.Activated] = props.onClickCallback,
    })
end
```

#### React/ReactRoblox Code:
```lua
local React = require(Packages.React)
local ReactRoblox = require(Packages.ReactRoblox)

function GenericComponent(props)
    -- use React.createElement
    return React.createElement("TextButton", {
        BackgroundColor3 = props.color,
	-- Use ReactRoblox for event callbacks
	[ReactRoblox.Event.Activated] = props.onClickCallback,
    })
end
```

!!! info

	Right now, the ReactRoblox package owns the `Event` and `Change` logic. This is because these features are specific to the Roblox engine and its event semantics. In the future, we'd like to explore the idea of hoisting them into the React package, so that they can be generalized for the ReactTestRenderer to improve compatibility and remove renderer-specific abstractions from component definitions.

### Using Hooks
Be sure to use the `React` and `ReactRoblox` API when writing code with hooks. `RoactCompat` **does not** export the hooks API.

#### Hooks Example
```lua
local React = require(Packages.React)
local ReactRoblox = require(Packages.ReactRoblox)

function ClickerComponent(props)
    -- useState is exported through React
    local count, setCount = React.useState(0)
    local function onClick()
        setCount(function(oldCount)
             return oldCount + 1
        end)
    end
    -- use React.createElement
    return React.createElement("TextButton", {
        Text = tostring(count),
	-- Use ReactRoblox
        [ReactRoblox.Event.Activated] = onClick,
    })
end
```

## Under construction ðŸ”¨

While not necessary to function properly, some additional changes can be made to adopt the naming conventions and API shape of React JS.

### Component Lifecycle Names

### Context.Consumer

### Fragments

#### Implicit Fragments

#### React.Fragment

### ReactRoblox.createPortal

### Eliminating RoactCompat
